Numpy 
오리지널 파이썬보다 리소스를 더 적게 먹고, 훨씬 속도가 빠르기 때문에 대규모 계산에 numpy 를 사용

pandas 데이터프레임 

matplotlib 그래프 비쥬얼화를 쉽게 해준다
 - 많은 다른 전공자들이 이것을 사용하는 구체적인 이유

scipy 과학기술 전용
sympy 심볼릭 수학시간에 배운 변수를 그대로 표현
 = y = x+2x+1 (몇승이 들어가도 표현 가능)
 = 적분계산 (수학자 입장에서는 훌륭한 도구)
but 우리에게는 그렇게 쓸모없다.

Statsmodel 통계용
Seaborn 통계용

nltk (national languages tool kit)
언어분석해주는 툴 (알파벳 기반)
konlpy 
한국어 기반으로 언어분석해주는 툴




Numpy 

pandas  

matplotlib 

우리는 3개만 집중적으로 할 것.

하둡에 있는 파이썬을 이용해서 데이터 스크립을 빼와서 여기서 진행

시간이 남으면 책에 있는 예제를 진행할것.


------------------------------------------------------------------------

쥬피터 노트북은 딥러닝이나 머신러닝과 같은 결과를 바로 보면서 수정할 수 있는 작업에 용이

이번주는 파이참으로 진행.

-----------------------------------------------------------------------------------------

파이썬에서 제공하는 시퀀스 리스트, 튜플 (연속되는 데이터)

import numpy as np

data1 = [0, 1, 2, 3, 4, 5]
a1 = np.array(data1)
print(a1)

 [0 1 2 3 4 5]
이건 파이썬 리스트가 아니라 넘파이에서 제공하는 넘파이 배열
** 내부 구조가 완전히 다름

data2 = [0,1,5,4,12,0.5]
a2 = np.array(data2)
print(a2)

정수 실수의 조합일때는 전부 실수로 만들어줌

[ 0.   1.   5.   4.  12.   0.5]	 * 시험문제 ' . ' 이 들어가야 함



print(a1.dtype)
print(a2.dtype)

실제로 타입을 검색해보면

int32
float64

인트와 실수타입이라고 알려줌
---------------------------------------------------------------------------------

a3 = np.array([[1,2,3], [4,5,6], [7,8,9]])
print(a3)

[[1 2 3]
 [4 5 6]
 [7 8 9]]


이미지 프로세싱에서는 3차원까지 표현 가능 (사실 차원은 늘릴 수 있지만, 복잡해짐)

---------------------------------------------------------------------------------

a4 = np.arange(0, 10, 2) 0에서 9까지 2씩 증가
a5 = np.arange(1, 10) 1에서 10-1 까지
a6 = np.arange(5) 0에서 5-1 까지

print(a4)
print(a5)
print(a6)

[0 2 4 6 8]
[1 2 3 4 5 6 7 8 9]
[0 1 2 3 4]

------------------------------------------------------------------------------------------

a7 = np.arange(12).reshape(4, 3)  ** 0부터 11까지의 숫자
print(a7)

[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

열 4 행 3으로 만들어주기
** numpy 에서 가장 많이 사용하는 것.

a7 = np.arange(12).reshape(4, 3)
print(a7)
print('='*20)
print(a7.shape)

====================
(4, 3) 

** reshape 을 shape 으로 다시 바꿔주는 것. shape 결과는 언제나 튜플로 나온다.

print(a6.shape)

(5,) ** column 의 개수를 표현 (row 는 없으니)

** 대신 벡터를 계산할때는 row 라고 생각해야함 벡터는 세워서 생각해야 하니까
** (1, 2, 3, 4) -> 벡터 계산시
(1
2
3
4)

---------------------------------------------------------------

a8 = np.arange(11).reshape((4, 3))
print(a8)

arange 개수와 reshape 타입의 수가 안맞으면 에러 발생시킴

-----------------------------------------------------------------------------------

a1 = np.linspace(1, 10, 10)  ** 10까지 포함됨
print(a1)

[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]

1부터 10까지의 숫자를 10개로 균등하게 쪼개라 
실수로 나온 이유는, 몇개로 나오게 할지 모르니 그렇다.

예를 들어.

a1 = np.linspace(1, 10, 8)  ** 8개로 균등하게 쪼개라고 했을시
print(a1)

[ 1.          2.28571429  3.57142857  4.85714286  6.14285714  7.42857143
  8.71428571 10.      ]  

1부터 10까지의 숫자를 8개로 균등하게 쪼개서 출력


a3 = np.linspace(0, np.pi, 20)
print(a3)

[0.         0.16534698 0.33069396 0.49604095 0.66138793 0.82673491
 0.99208189 1.15742887 1.32277585 1.48812284 1.65346982 1.8188168
 1.98416378 2.14951076 2.31485774 2.48020473 2.64555171 2.81089869
 2.97624567 3.14159265]

0에서 (np에서 제공하는 파이) 사이를 20개로 쪼개라.
* 이런 특성 때문에 수학자들이 numpy 를 좋아한다.

-------------------------------------------------------------------------------------

a1 = np.zeros(10, int) 
print(a1)

[0 0 0 0 0 0 0 0 0 0]

10개의 수를 만드는데, 인트 타입의 0 으로 출력한다.

a2 = np.zeros((3, 4), int)
print(a2)

[[0 0 0 0]
 [0 0 0 0]
 [0 0 0 0]]

2차원 이상 배열을 만들때
** 항상 첫번째 인자가 reshape 모형이고 두번째는 타입

------------------------------------------------------------------------------------

a3 = np.ones(5)
print(a3)

[1. 1. 1. 1. 1.]

a4 = np.ones((3,5))	  //튜플 형식으로 해야함, 타입을 지정하지 않았을때는 실수로 제공
print(a4)

[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]

-----------------------------------------------------------------------------------

a5 = np.eye(3)
print(a5)

[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]

단위행렬 만들어주는 메서드

-------------------------------------------------------------------------------------------------

왼쪽 위에서 오른쪽 아래로 대각선 방향(↘)의 성분이 1이고 
다른 성분은 모두 0인 n차 정사각형렬을 n차 단위행렬이라고 하고 기호로 E로 나타내요
(파이썬에서는 eye 로 표현)

**군론을 비롯한 대수학에서, 항등원(恒等元, 영어: identity element 또는 neutral element,단위원)이란 
임의의 수 a에 대하여 어떤 수를 연산했을 때 처음의 수 a가 되도록 만들어 주는 수를 말한다.

예를 들어 a + ? = a 
? = 0

a * ? = a
? = 1

** 메트릭스 곱셈 잘 알아두기

-------------------------------------------------------------------------------------------

a1 = np.array(['abc', 'whoami'])
print(a1)
print(a1.dtype)

['abc' 'whoami']
<U6	**numpy 데이터 타입 유니코드 문자열
** 더 찾아볼 것. 

-----------------------------------------------------------------------------------------------------


a1 = np.array(['1.567', '0.123', '5.232', '5', '8'])
num = a1.astype(float)
print(a1)
print(a1.dtype)
print(num)
print(num.dtype)

['1.567' '0.123' '5.232' '5' '8']
<U5
[1.567 0.123 5.232 5.    8.   ]
float64

문자열 을 넣으면 에러가 난다. **문자열로 바꾸고 싶으면 2번째 마지막은 (str)로 바꿔줌


a1_f = np.array([10, 20, 0.345, 5.87, 9.12])
a1_i = a1_f.astype(int)
print(a1_f)
print(a1_f.dtype)
print(a1_i)
print(a1_i.dtype)

[10.    20.     0.345  5.87   9.12 ]
float64
[10 20  0  5  9]
int32

int 타입으로 바꾸면 반올림 적용

----------------------------------------------------------------------------------------------------

a1 = np.random.rand()
print(a1)

[0,1) <- 표현방식 
0을 포함하고 1을 포함하지 않는 수
0에서 1 사이의 랜덤수를 출력

a2 = np.random.rand(2, 3)
print(a2)

[[0.37248503 0.47127409 0.65169323]
 [0.5117829  0.34056413 0.50190621]]

2열 3행의 난수를 출력

a3 = np.random.rand(2, 3, 4)
print(a3)

[[[0.89876083 0.93494417 0.40037044 0.03101109]
  [0.81960861 0.83419947 0.28414144 0.06865297]
  [0.20200321 0.91977064 0.98711535 0.93215948]]

 [[0.16526283 0.79503782 0.77065015 0.3512435 ]
  [0.59200246 0.76079986 0.63128906 0.62356098]
  [0.93519544 0.98673735 0.36525556 0.36591361]]]

3열 4행의 난수 2개를 출력 (3차원)

------------------------------------------------------------------------------------------------------

a1 = np.random.randint(10, size=(3, 4))
print(a1)

[[1 3 7 2]
 [8 0 4 5]
 [2 6 7 1]]

np.random.randint([low,] high, [, size]) <== [low, high] 사이의 정수 난수
0 부터 시작 (생략했으니)

a2 = np.random.randint(1, 30)
print(a2)

1부터 30중 하나를 랜덤하게 출력

----------------------------------------------------------------------------------------------

a1 = np.array([10, 20, 30, 40])
a2 = np.array([1, 2, 3, 4])
print(a1 + a2)
print(a1 - a2)
print(a1 * 2)
print(a1 ** 2)
print(a1 * a2)
print(a1 / a2)
print(a1 / (a2**2))
print(a1 > 20)

[11 22 33 44]
[ 9 18 27 36]
[20 40 60 80]
[ 100  400  900 1600]
[ 10  40  90 160]
[10. 10. 10. 10.]
[10.          5.          3.33333333  2.5       ]
[False False  True  True]


a1, a2 의 인자값 개수만 맞는다면 사칙연산 전부 적용 가능

-----------------------------------------------------------------------------------------------

a1 = np.arange(1, 6) 
print(a1.sum()) 	* 1~5 까지 합
print(a1.mean())	
print(a1.var())   * 분산, 값들이 얼마나 분포되어 있는지 나타내는 것
print(a1.std())   * 표준편차 
print(a1.min())   * 최소값
print(a1.max())   * 최대값
print(a1.cumsum())  * (누적값)첫번째 인자값에서 두번째를 더하고, 더한 값에 세번째 인자값을 더함..이어짐
print(a1.cumprod())  * (누적곱)

15
3.0
2.0
1.4142135623730951
1
5
[ 1  3  6 10 15]
[  1   2   6  24 120]


분산으로 표준편차 구할 수 있음
분산(variance)은 관측값에서 평균을 뺀 값을 제곱하고, 그것을 모두 더한 후 전체 개수로 나눠서 구한다. 
즉, 차이값의 제곱의 평균이다. 
관측값에서 평균을 뺀 값인 편차를 모두 더하면 0이 나오므로 제곱해서 더한다.

분산의 양수 음수값이 있을 수 있으니
전부 (양수로 만들기 위해) 제곱해서 루트를 씌우고
그 값을 n-1 값으로 나눈다. 여기서는 n-1 = 5

------------------------------------------------------------------------------------------------------

numpy 에서 제공하는 행렬

a = np.array([0, 1, 2, 3]).reshape(2, 2)
print(a)

b = np.array([3, 2, 0, 1]).reshape(2, 2)
print(b)

print(b)
print('-' * 20)
print(a.dot(b))	*행렬곱
print(np.dot(a, b))  *행렬곱
print('-' * 20)
print(np.transpose(a))	*전치행렬  
print(a.transpose())		*전치행렬
print(np.linalg.inv(a))	*역행렬
print(np.linalg.det(a))	*행렬식

	
[[0 1]
 [2 3]]
[[3 2]
 [0 1]]

--------------------
[[0 1]
 [6 7]]
[[0 1]
 [6 7]]

--------------------
[[0 2]
 [1 3]]
[[0 2]
 [1 3]]

---------------------

[[-1.5  0.5]
 [ 1.   0. ]]

----------------------

-2.0

-----------------------------------------------------------------------------------------------------------

선형대수학에서, 전치 행렬(轉置行列, 영어: transposed matrix)은 행과 열을 교환하여 얻는 행렬이다. 
즉, 주대각선을 축으로 하는 반사 대칭을 가하여 얻는 행렬이다. 


------------------------------------------------------------------------------------------------------------

a = np.array([0,10,20,30,40,50])
print(a[0])
print(a[4])
a[5] = 90
print(a)
print(a[[1, 3, 4]])

0
40
[ 0 10 20 30 40 90]
[10 30 40]

** numpy 에서도 인덱스로 출력할 수 있다.


b = np.arange(10, 100, 10).reshape(3, 3)
print(b)
print(b[0, 2])
b[2, 2] = 97
print(b)

print(b[1])

print('-' * 20)
b[1] = np.array([45, 55, 65])
print(b)
b[2] = [75, 85, 95]
print(b)
print('-' * 20)
print(b[[0, 2], [0, 1]])   * 0,0 값 , 2,1 값 * 대괄호 2개// 잘 살피기


[[10 20 30]
 [40 50 60]
 [70 80 90]]
30
[[10 20 30]
 [40 50 60]
 [70 80 97]]

[40 50 60]

--------------------

[[10 20 30]
 [45 55 65]
 [70 80 97]]
[[10 20 30]
 [45 55 65]
 [75 85 95]]
--------------------

[10 85]  * 0,0 값 , 2,1 값

-----------------------------------------------------------------------------------------------------------

a = np.array([1, 2, 3, 4, 5, 6])
print(a[a > 3])
print(a[a % 2 == 0]) * 짝수만

[4 5 6]
[2 4 6]

 
-------------------------------------------------------------------------------------------------------------

a = np.array([0, 10, 20, 30, 40 ,50])
print(a[1:4])
print(a[:3])
print(a[2:])
a[2:5] = np.array([25, 35, 45])
print(a)

[10 20 30]
[ 0 10 20]
[20 30 40 50]
[ 0 10 25 35 45 50]

-------------------------------------------------------------------------------------------------------

a = np.arange(10, 100, 10).reshape(3, 3)
print(a)
print(a[1:3, 1:3])  #행 슬라이싱 // 열 슬라이싱
print(a[:3, 1:])
print(a[1][0:2])
a[0:2, 1:3] = np.array([[25, 35], [55, 65]])
print(a)

[[10 20 30]
 [40 50 60]
 [70 80 90]]

[[50 60]
 [80 90]]

[[20 30]
 [50 60]
 [80 90]]

[40 50]

[[10 25 35]
 [40 55 65]
 [70 80 90]]

-------------------------------------------------------------------------------------------------------


pandas 시작

import pandas as pd
** pandas 에는 Series 와 DataFrame 만 있음

s1 = pd.Series([10, 20, 30, 40, 50])
print(s1)

0    10
1    20
2    30
3    40
4    50

index 자동생성해줌

print(s1.index)
print(s1.values)

RangeIndex(start=0, stop=5, step=1)
[10 20 30 40 50] <- 얘는 파이썬의 리스트 배열이 아닌 numpy 배열이다.

---------------------------------------------------------------------------------------------------------

s2 = pd.Series(['a', 'b', 'c', 1, 2, 3])
print(s2)

[10 20 30 40 50]
0    a
1    b
2    c
3    1
4    2
5    3
dtype: object

** 서로 다른 타입을 object 에 넣을 수 있음
** numpy 와 가장 많이 다른 점

s3 = pd.Series([np.nan, 1, 2])
print(s3)

0    NaN   * non of number
1    1.0
2    2.0
dtype: float64

** 원하는 경우 값을 넣지 않을수도 있다.

s3 = pd.Series([np.nan, 1, 2], dtype='Int32')

0    <NA>	* not available
1       1
2       2
dtype: Int32
print(s3)

** Int 타입으로 변환도 가능

------------------------------------------------------------------------------------------------------------

index_date = ['2020-03-20', '2020-03-21', '2020-03-22', '2020-03-23']
s4 = pd.Series([200, 187, np.nan, 210], index= index_date)
print(s4)

2020-03-20    200.0
2020-03-21    187.0
2020-03-22      NaN
2020-03-23    210.0
dtype: float64

---------------------------------------------------------------------------------------------------------------

s5 = pd.Series({'국어': 100, '영어':95, '수학':100})
print(s5)

국어    100
영어     95
수학    100
dtype: int64

** 딕셔너리에서는 기본 키 타입은 문자열 기본 값 타입은 int
** key 값을 index 로 잡아준다.

-----------------------------------------------------------------------------------------------------------------

pd.date_range(start=None, end=None, periods=None, freq='D')
# 시작날짜, 끝날짜, 기간, 생성주기
** pandas 를 이거 하나때문에 사용하는 사람이 있을정도로 파워풀함

p = pd.date_range(start='2020-01-20', end='2020-01-27')
print(p)

DatetimeIndex(['2020-01-20', '2020-01-21', '2020-01-22', '2020-01-23',
               '2020-01-24', '2020-01-25', '2020-01-26', '2020-01-27'],
              dtype='datetime64[ns]', freq='D')


p = pd.date_range(start='2020/01/20', end='2020.01.27')
print(p)

날짜 사이에 '/' 혹은 ' . ' 을 사용해도 상관없지만 결과는

DatetimeIndex(['2020-01-20', '2020-01-21', '2020-01-22', '2020-01-23',
               '2020-01-24', '2020-01-25', '2020-01-26', '2020-01-27'],
              dtype='datetime64[ns]', freq='D')  **date_range 의 객체

' - ' 로 같게 나온다.

----------------------------------------------------------------------------------------------------------------

p = pd.date_range(start='2020/01/20', periods=7)     ** 7일간.
print(p)

DatetimeIndex(['2020-01-20', '2020-01-21', '2020-01-22', '2020-01-23',
               '2020-01-24', '2020-01-25', '2020-01-26'],
              dtype='datetime64[ns]', freq='D')

** 같은 결과


---------------------------------------------------------------------------------------------------------------------

p = pd.date_range(start='2020/01/01', periods=4, freq='2D')
print(p)

DatetimeIndex(['2020-01-01', '2020-01-03', '2020-01-05', '2020-01-07'], dtype='datetime64[ns]', freq='2D')

start 부터 2Day 씩 4번(start day 포함)


p = pd.date_range(start='2020/01/01', periods=5, freq='w')
print(p)

DatetimeIndex(['2020-01-05', '2020-01-12', '2020-01-19', '2020-01-26',
               '2020-02-02'],
              dtype='datetime64[ns]', freq='W-SUN')  **일요일 기준

start 부터 1week 씩 5번(start day 포함)



p = pd.date_range(start='2020/01/01', periods=12, freq='2BM')
print(p)

DatetimeIndex(['2020-01-31', '2020-03-31', '2020-05-29', '2020-07-31',
               '2020-09-30', '2020-11-30', '2021-01-29', '2021-03-31',
               '2021-05-31', '2021-07-30', '2021-09-30', '2021-11-30'],
              dtype='datetime64[ns]', freq='2BM')  2Business Month

start 부터 2months 씩 12번(start day 포함)  ** 주 5일 기준으로 / 업무일 기준으로 / 월말



p = pd.date_range(start='2020/01/03', periods=4, freq='QS')
print(p)

DatetimeIndex(['2020-04-01', '2020-07-01', '2020-10-01', '2021-01-01'], dtype='datetime64[ns]', freq='QS-JAN')

4분기 기준으로 3개월 단위



p = pd.date_range(start='2020/01/01', periods=4, freq='AS')
print(p)

DatetimeIndex(['2020-01-01', '2021-01-01', '2022-01-01', '2023-01-01'], dtype='datetime64[ns]', freq='AS-JAN')

1년 단위 4번


--------------------------------------------------------------------------------------------------------------------------

p = pd.date_range(start='2020/01/01 08:00', periods=10, freq='H')
print(p)

DatetimeIndex(['2020-01-01 08:00:00', '2020-01-01 09:00:00',
               '2020-01-01 10:00:00', '2020-01-01 11:00:00',
               '2020-01-01 12:00:00', '2020-01-01 13:00:00',
               '2020-01-01 14:00:00', '2020-01-01 15:00:00',
               '2020-01-01 16:00:00', '2020-01-01 17:00:00'],
              dtype='datetime64[ns]', freq='H')

8시 기준 start 1시간씩 10번



p = pd.date_range(start='2020/01/01 08:00', periods=10, freq='BH')
print(p)

DatetimeIndex(['2020-01-01 09:00:00', '2020-01-01 10:00:00',
               '2020-01-01 11:00:00', '2020-01-01 12:00:00',
               '2020-01-01 13:00:00', '2020-01-01 14:00:00',
               '2020-01-01 15:00:00', '2020-01-01 16:00:00',
               '2020-01-02 09:00:00', '2020-01-02 10:00:00'],
              dtype='datetime64[ns]', freq='BH')

** BH 17:00 퇴근 기준 

print(pd.offsets.BusinessHour())
<BusinessHour: BH=09:00-17:00>

import datetime
bh = pd.offsets.BusinessHour(start='09:00', end=datetime.time(18, 0))
p2 = pd.date_range(start='2020/01/01 08:00', periods=10, freq='BH') + bh
print(p2)

DatetimeIndex(['2020-01-01 10:00:00', '2020-01-01 11:00:00',
               '2020-01-01 12:00:00', '2020-01-01 13:00:00',
               '2020-01-01 14:00:00', '2020-01-01 15:00:00',
               '2020-01-01 16:00:00', '2020-01-01 17:00:00',
               '2020-01-02 10:00:00', '2020-01-02 11:00:00'],
              dtype='datetime64[ns]', freq=None)

** 18시로 교체 후 다시 출력하면 17시까지 출력해주는걸 확인할 수 있다.


print(pd.offsets.BusinessHour())
import datetime

import warnings
warnings.simplefilter(action='ignore', category=pd.errors.PerformanceWarning)  

bh = pd.offsets.BusinessHour(start='09:00', end=datetime.time(18, 0))
p2 = pd.date_range(start='2020/01/01 08:00', periods=10, freq='BH') + bh
print(p2)

** 위 값 결과 출력시 Warning 나오는데 Warning 없게 하기 위해선 import warnings, ignore 적용
** start 시간을 한시간 늘려 퇴근을 늘렸기 때문에 다른 방법을 찾지 않는 이상 무용지물


----------------------------------------------------------------------------------------------------------------


p = pd.date_range(start='2020-01-01 10:00', periods=4, freq='30min')
print(p)

DatetimeIndex(['2020-01-01 10:00:00', '2020-01-01 10:30:00',
               '2020-01-01 11:00:00', '2020-01-01 11:30:00'],
              dtype='datetime64[ns]', freq='30T')

30분 단위로 4개 만들기

DatetimeIndex(['2020-01-01 10:00:00', '2020-01-01 10:00:10',
               '2020-01-01 10:00:20', '2020-01-01 10:00:30'],
              dtype='datetime64[ns]', freq='10S')

10초 단위로 4개 만들기


** 각각 조합해서도 사용가능


----------------------------------------------------------------------------------------------------------------------


index_date = pd.date_range(start='2020-05-01 10:00', periods=5, freq='D')
p = pd.Series([51, 63, 59, 48, 60], index=index_date)
print(p)

2020-05-01 10:00:00    51
2020-05-02 10:00:00    63
2020-05-03 10:00:00    59
2020-05-04 10:00:00    48
2020-05-05 10:00:00    60
Freq: D, dtype: int64


----------------------------------------------------------------------------------------------------------------------

DataFrame

pandas 말고도 다른 분야에서도 많이 사용한다.

df = pd.DataFrame(data, [, index=index_data, columns-columns_data])

data : 리스트, 딕셔니리, NumPy배열, Series, DataFrame

DataFrame의 세로축은 index, 가로축은 columns 라 함

index 와 columns 를 제외한 영역은 values 라 함

index와 coulmns 의 기본값은 숫자 0부터 입력


----------------------------------------------------------------------------------------------------------------------

df = pd.DataFrame([[1,2,3], [4,5,6], [7,8,9]])
print(df)

   0  1  2
0  1  2  3
1  4  5  6
2  7  8  9


2차원 배열로 index , columns 값이 기본 0 1 2 출력됨



data_list = np.array([[1,2,3], [4,5,6], [7,8,9]])
df = pd.DataFrame(data_list)
print(df)

   0  1  2
0  1  2  3
1  4  5  6
2  7  8  9

Numpy 를 이용해서 만들기
배열의 개념이 아닌 아예 다른 DataFrame 객체를 구성한것 (물론, 내부적으로 들어가면 리스트 자체는 numpy속성)

----------------------------------------------------------------------------------------------------------------------

data = np.array([[1,2,3], [4,5,6], [7,8,9], [10,11,12]])
index_date = pd.date_range('2020-05-01', periods=4)
columns_list = ['A', 'B', 'C']
df = pd.DataFrame(data, index=index_date, columns=columns_list)
print(df)

                 A   B   C
2020-05-01   1   2   3
2020-05-02   4   5   6
2020-05-03   7   8   9
2020-05-04  10  11  12


** 각 칼럼과 인덱스 개수가 맞아야만 실행 가능


data = {'연도': [2015, 2016, 2016, 2017, 2017],
        '지사': ['서울', '서울', '부산', '서울', '부산'],
        '고객 수': [200, 250, 150, 300, 200]}

df = pd.DataFrame(data)
print(df)

     연도  지사  고객 수
0  2015  서울   200
1  2016  서울   250
2  2016  부산   150
3  2017  서울   300
4  2017  부산   200

** 딕셔너리 타입으로 구성하면, 키들이 컬럼으로 가고, 값들이 해당 컬럼의 values 가 된다.

data = {'연도': [2015, 2016, 2016, 2017, 2017],
        '지사': ['서울', '서울', '부산', '서울', '부산'],
        '고객 수': [200, 250, 150, 300, 200]}

df = pd.DataFrame(data, columns=['지사', '연도', '고객 수'])
print(df)

   지사    연도  고객 수
0  서울  2015   200
1  서울  2016   250
2  부산  2016   150
3  서울  2017   300
4  부산  2017   200

해당 컬럼의 순서도 바꿀 수 있다.



print(df.index)
print(df.columns)
print(df.values)


RangeIndex(start=0, stop=5, step=1)
Index(['지사', '연도', '고객 수'], dtype='object')
[['서울' 2015 200]
 ['서울' 2016 250]
 ['부산' 2016 150]
 ['서울' 2017 300]
 ['부산' 2017 200]]

----------------------------------------------------------------------------------------------------------------------


s1 = pd.Series([1,2,3,4,5])
s2 = pd.Series([10,20,30,40,50])
print(s1 + s2)
print(s1 - s2)
print(s1 * s2)
print(s1 / s2)


0    11
1    22
2    33
3    44
4    55
dtype: int64
0    -9
1   -18
2   -27
3   -36
4   -45
dtype: int64
0     10
1     40
2     90
3    160
4    250
dtype: int64
0    0.1
1    0.1
2    0.1
3    0.1
4    0.1
dtype: float64


s3 = pd.Series([1,2,3,4])
s4 = pd.Series([10,20,30,40,50])
print(s3 + s4)

0    11.0
1    22.0
2    33.0
3    44.0
4     NaN
dtype: float64

** pandas 의 Series 는 크기가 달라도 연산은 가능하다. 계산은 가능하다.

--------------------------------------------------------------------------------------------------------------

data1 = {'A': [1,2,3,4,5],
         'B': [10,20,30,40,50],
         'C': [100,200,300,400,500]}
df1 = pd.DataFrame(data1)
print(df1)

data2 = {'A': [6,7,8],
         'B': [60,70,80],
         'C': [600,700,800]}
df2 = pd.DataFrame(data2)
print(df2)
print('=' * 20)
print(df1 + df2)



   A   B    C
0  1  10  100
1  2  20  200
2  3  30  300
3  4  40  400
4  5  50  500
   A   B    C
0  6  60  600
1  7  70  700
2  8  80  800
====================
      A      B       C
0   7.0   70.0   700.0
1   9.0   90.0   900.0
2  11.0  110.0  1100.0
3   NaN    NaN     NaN
4   NaN    NaN     NaN


사이즈가 다르니 계산은 되지만, 중복되지 않는 부분은 NaN 으로 나옴

----------------------------------------------------------------------------------------------------------------

df1 = pd.DataFrame({'Class1': [95, 92, 98, 100],
                    'Class2': [91, 93, 97, 99]})

print(df1)

df2 =  pd.DataFrame({'Class1': [87, 89],
                     'Class2': [85, 90]})

print('=' * 40)
print(df2)
print('=' * 40)
print(df1.append(df2))

   Class1  Class2
0      95      91
1      92      93
2      98      97
3     100      99
========================================
   Class1  Class2
0      87      85
1      89      90
========================================
   Class1  Class2
0      95      91
1      92      93
2      98      97
3     100      99
0      87      85
1      89      90


append 하면 밑에서 붙임

df4 = pd.DataFrame({'Class3': [93, 91, 95, 98]})
print(df4)
print('=' * 40)
print(df1.join((df4)))

   Class3
0      93
1      91
2      95
3      98
========================================
   Class1  Class2  Class3
0      95      91      93
1      92      93      91
2      98      97      95
3     100      99      98

join 은 옆에다 붙임

--------------------------------------------------------------------------------------------------------------

df_A_B = pd.DataFrame({'판매월': ['1월', '2월', '3월', '4월'],
                       '제품A': [100, 150, 200, 130],
                       '제품B': [90, 110, 140, 170]})
print(df_A_B)

df_C_D = pd.DataFrame({'판매월': ['1월', '2월', '3월', '4월'],
                       '제품C': [112, 141, 203, 134],
                       '제품D': [90, 110, 140, 170]})

print('=' * 40)
print(df_C_D)
print('=' * 40)
print(df_A_B.merge(df_C_D))


  판매월  제품A  제품B
0  1월  100   90
1  2월  150  110
2  3월  200  140
3  4월  130  170
========================================
  판매월  제품C  제품D
0  1월  112   90
1  2월  141  110
2  3월  203  140
3  4월  134  170
========================================
  판매월  제품A  제품B  제품C  제품D
0  1월  100   90  112   90
1  2월  150  110  141  110
2  3월  200  140  203  140
3  4월  130  170  134  170

기본동작은 join 과 같다

 

df_left = pd.DataFrame({'key':['A', 'B', 'C'], 'left': [1,2,3]})
print(df_left)
print('='*40)
df_right = pd.DataFrame({'key': ['A', 'B', 'D'], 'right': [4,5,6]})
print(df_right)

print('='*40)
print(df_left.merge(df_right, how='left', on='key'))

  key  left
0   A     1
1   B     2
2   C     3
========================================
  key  right
0   A      4
1   B      5
2   D      6
========================================
  key  left  right
0   A     1    4.0
1   B     2    5.0
2   C     3    NaN


기준점 기준 데이터가 더 많은쪽이 나오고 없는쪽은 NaN 으로 출력


print(df_left.merge(df_right, how='right', on='key'))

  key  left  right
0   A   1.0      4
1   B   2.0      5
2   D   NaN      6

만약 how 기준을 right 로 주면 D 값이 없는 left는 NaN 으로 나옴  


print(df_left.merge(df_right, how='outer', on='key'))


  key  left  right
0   A   1.0    4.0
1   B   2.0    5.0
2   C   3.0    NaN
3   D   NaN    6.0

outer 는 전부 출력 // 전체 잘 보고

print(df_left.merge(df_right, how='inner', on='key'))

  key  left  right
0   A     1      4
1   B     2      5

inner 는 공통된 값만 출력  ** 시험문제!
