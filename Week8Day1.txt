지금까지 핸들링 했던 데이터들이 엄청나게 큰 데이터로 가게 되면
여러대의 컴퓨터가 필요하고 
클러스터링을 해서 나누게 되었을대

한곳에 모아 데이터를 뽑아주는게 하둡이다
자바 기반 하둡

하지만 하둡은 리눅스 기반이기 때문에 리눅스도 공부해야 한다.
그래서 수업에 들어가 있음

----------------------------------------------------------------------


Regular Expression

문자열의 패턴을 수학적으로 정의할 수 있는 도구

정의해서 뭐합니까
기본적으로 해당 문자열을 주어진 것에서 파싱해서 맞는지 보는거
compile 하는거

언어를 정의하는 것.

문자열의 패턴을 인식하는 세계공통의 언어

it 하는 사람들끼리 Regular Expression 으로 소통할 수 있음


--------------------------------------------------------------------------


간단하게 기본적인것들만 이해할 수 있게 해줄거임

# 대괄호( [] ) 사이의 문자와 매칭하라는 의미

# 대괄호( [  ] ) 사이의 문자는 기본적으로 or 로 조합됨

# [abc] 해당 텍스트에 a 또는 b 또는 c 라는 문자가 있는지 검사

# [Tt]om - Tom 또는 tom 을 찾음


import re

p = re.compile(r"[Tt]om")   # 이 문자는 regular expression 패턴 문자다 를 알려주기 위해 r 을 붙힘
print(p.match("Tom is a sutdent"))
print(p.match("My name is Tom"))


** 

<re.Match object; span=(0, 3), match='Tom'>
None
## span 은 0부터 2까지 매칭이 되었다고 알려줌
## 아무 옵션도 주지 않았기 때문에 처음 말고는 읽을 수 없음

---------------------------------------------------------------------------------

print(re.match(r'[A-Za-z][0-9]', '12345'))

**
None
# 첫번째는 A-Za-z 중 하나가 와야하고 그 다음이 0-9 중 하나가 와야 한다.



print(re.match(r'[A-Za-z][0-9]', 'a12345'))<re.Match object; span=(0, 2), match='a1'>

<re.Match object; span=(0, 2), match='a1'>

----------------------------------------------------------------------------------

print(re.match(r'[가-힣]', '나라'))

<re.Match object; span=(0, 1), match='나'>

# 한글이 반드시 하나라도 들어가게 하기 위해서.

----------------------------------------------------------------------------------

p = re.compile(r"[0-16-9]{3}-[0-9]{3,4}-[0-9]{4}")
p = re.compile(r"01[016789]-[0-9]{3,4}-[0-9]{4}")

# 0에서 1 그리고 6에서9까지 중 3개, 0에서 9까지중 3 or 4 개, 0-9까지 중 4개

result = p.match('016-245-8765')
print(result)

# 조건에 들어가있는 것에 충족하는 모든 숫자들이 올 수 있다.

-------------------------------------------------------------------------------------


p = re.compile(r'abc[0-9]*def')
# abc 나오고 (0-9 숫자가 나올수도 있고 아닐수도 있고) 끝에는 def 가 붙는다.
                  = 이걸 뜻하는게 * 다, 만약 * 가 없다면 반드시 1개가 나와야 한다.

result = p.match('abc3def')
result1 = p.match('abc3456def')
result2 = p.match('abcdef')
print(result)
print(result1)
print(result2)

**
<re.Match object; span=(0, 7), match='abc3def'>
<re.Match object; span=(0, 10), match='abc3456def'>
<re.Match object; span=(0, 6), match='abcdef'>

------------------------------------------------------------------------------------

p = re.compile(r'abc[0-9]*[A-Za-z0-9]*def')
			= A-z 대문자 소문자 숫자 전부 나와도 상관없다.


-------------------------------------------------------------------------------------

p = re.compile(r'[^5]abc')  <- 5만빼고 다 올 수 있다 (문자열도 올 수 있다)
result = p.match('1abc')	  여기에 * 들어가면 [^5] 에 5만 빼고 다른 문자 다 올 수 있다.
print(result)		  ^ <- not 을 뜻함

<re.Match object; span=(0, 4), match='1abc'>

-----------------------------------------------------------------------------------------

p = re.compile(r'abc[0-9]?def') <- 0 또는 1회 즉, 숫자를 넣지 않거나 한번만 들어가야함
result = p.match('abcdef')
print(result)

<re.Match object; span=(0, 6), match='abcdef'>


# 대괄호 밖의 ^ = 문자열의 스타트, $ 문자열의 엔드

p = re.compile(r'^3[A-Za-z]+9$') 

# 문자열의 시작은 반드시 3으로 시작하고 A-z 중 꼭 하나 이상이 나와야하며, 9로 끝나야 한다.

-----------------------------------------------------------------------------------------------------

p = re.compile('[0-9].8$')
# 0-9 중 하나가 나오고   . <- 아무거나 하나오고 8로 끝나야 한다.
# .. <- 2개 ...<- 3개 아무거나 와라

# \ 를 하면 본래의 의미가 아닌 평범한녀석으로 돌아온다.

------------------------------------------------------------------------------------------------

p = re.compile(r'abc[0-9]?def') <- ? 아예 안쓰거나 한번만 쓰거나, 0 또는 1회
result = p.match('abc1def')
print(result)

------------------------------------------------------------------------------------------

p = re.compile(r'\dabc') <- \d 문자 하나만 온다.
print(p.match('1abc'))
print(p.match('123abc'))

<re.Match object; span=(0, 4), match='1abc'>
None

-----------------------------------------------------------------------------------------


p = re.compile(r'\D123') <- Non digit 숫자가 오면 안된다
print(p.match('a123'))
print(p.match('8123'))

<re.Match object; span=(0, 4), match='a123'>
None

p = re.compile(r'abc\s[0-9]+')   <- 스페이스 하나
print(p.match('abc 76'))
print(p.match('abc98'))

<re.Match object; span=(0, 6), match='abc 76'>
None

p = re.compile(r'abc\S[0-9]+') <- 스페이스가 아닌 모든 것
print(p.match('abc 76'))
print(p.match('abc98'))

None
<re.Match object; span=(0, 5), match='abc98'>
